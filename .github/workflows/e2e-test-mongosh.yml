name: E2E Test - DocumentDB with mongosh

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  schedule:
    # Run daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      documentdb_version:
        description: 'DocumentDB image version to test'
        required: false
        default: '16'
      node_count:
        description: 'Number of DocumentDB nodes'
        required: false
        default: '1'
      test_level:
        description: 'Test level to run'
        required: false
        default: 'full'
        type: choice
        options:
          - quick
          - integration
          - full

permissions:
  packages: write
  contents: read
  id-token: write
  actions: read
  attestations: write

env:
  CERT_MANAGER_NS: cert-manager
  OPERATOR_NS: documentdb-operator
  DB_NS: documentdb-e2e-test
  DB_NAME: documentdb-e2e
  DB_USERNAME: default_user
  DB_PASSWORD: Admin100
  DB_PORT: 10260

jobs:
  # Use the reusable build workflow
  build:
    name: Build Images and Charts
    uses: ./.github/workflows/build-and-package.yml
    with:
      image_tag_prefix: 'e2e-test'
      chart_version_prefix: '0.1.0'
      push_to_registry: true
    secrets: inherit

  e2e-test:
    name: Run E2E Tests
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 60
    needs: build
    
    strategy:
      matrix:
        include:
          - architecture: amd64
            runner: ubuntu-latest
          - architecture: arm64
            runner: ubuntu-24.04-arm64
        # Test different scenarios
        test_scenario:
          - name: "single-node"
            node_count: 1
            instances_per_node: 1
    
    env:
      # Use outputs from the build workflow
      IMAGE_NAME: documentdb-kubernetes-operator
      IMAGE_TAG: ${{ needs.build.outputs.image_tag }}
      CHART_VERSION: ${{ needs.build.outputs.chart_version }}
      ARCHITECTURE: ${{ matrix.architecture }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Verify built image exists
      run: |
        echo "Verifying that our newly built image exists..."
        echo "Expected image: ghcr.io/${{ github.repository }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
        
        # Login to GHCR to check image
        echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
        
        # Try to pull the image to verify it exists
        docker pull ghcr.io/${{ github.repository }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
        echo "✓ Image verified successfully"

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl netcat-openbsd

    - name: Install Helm
      uses: azure/setup-helm@v3
      with:
        version: 'latest'

    - name: Install MongoDB Shell (mongosh)
      run: |
        echo "Installing mongosh for ${{ matrix.architecture }} architecture..."
        
        # Install mongosh using the official installation method
        curl -fsSL https://pgp.mongodb.com/server-7.0.asc | sudo gpg --dearmor -o /usr/share/keyrings/mongodb-server-7.0.gpg
        
        if [[ "${{ matrix.architecture }}" == "arm64" ]]; then
          echo "deb [ arch=arm64 signed-by=/usr/share/keyrings/mongodb-server-7.0.gpg ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/7.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-7.0.list
        else
          echo "deb [ arch=amd64 signed-by=/usr/share/keyrings/mongodb-server-7.0.gpg ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/7.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-7.0.list
        fi
        
        sudo apt-get update
        sudo apt-get install -y mongodb-mongosh
        mongosh --version
        echo "✓ mongosh installed successfully for ${{ matrix.architecture }}"

    - name: Create kind cluster
      uses: helm/kind-action@v1.8.0
      with:
        cluster_name: documentdb-e2e-${{ matrix.architecture }}-${{ matrix.test_scenario.name }}

    - name: Wait for cluster to be ready
      run: |
        echo "Waiting for ${{ matrix.architecture }} cluster to be ready..."
        kubectl cluster-info
        kubectl wait --for=condition=Ready nodes --all --timeout=300s
        
        # Verify node architecture
        echo "Node architecture verification:"
        kubectl get nodes -o jsonpath='{.items[*].status.nodeInfo.architecture}'
        echo ""

    - name: Install cert-manager
      run: |
        echo "Installing cert-manager on ${{ matrix.architecture }}..."
        helm repo add jetstack https://charts.jetstack.io
        helm repo update
        
        helm install cert-manager jetstack/cert-manager \
          --namespace $CERT_MANAGER_NS \
          --create-namespace \
          --set installCRDs=true \
          --wait --timeout=10m

    - name: Install DocumentDB Operator
      run: |
        echo "Installing DocumentDB Operator on ${{ matrix.architecture }} using newly built chart version: ${{ env.CHART_VERSION }}"
        
        # Log in to GHCR for Helm
        echo "${{ secrets.GITHUB_TOKEN }}" | helm registry login ghcr.io --username ${{ github.actor }} --password-stdin
        
        # Install the operator using the newly created chart
        helm install documentdb-operator oci://ghcr.io/${{ github.repository_owner }}/documentdb-operator \
          --version ${{ env.CHART_VERSION }} \
          --namespace $OPERATOR_NS \
          --create-namespace \
          --wait --timeout=15m
        
        kubectl wait --for=condition=Available deployment/documentdb-operator -n $OPERATOR_NS --timeout=300s
        
        # Verify that our newly built image is being used
        echo "Verifying operator deployment uses our newly built image on ${{ matrix.architecture }}..."
        kubectl get deployment documentdb-operator -n $OPERATOR_NS -o jsonpath='{.spec.template.spec.containers[0].image}'
        echo ""

    - name: Deploy DocumentDB Cluster - ${{ matrix.test_scenario.name }}
      run: |
        echo "Deploying DocumentDB cluster with configuration: ${{ matrix.test_scenario.name }} on ${{ matrix.architecture }}"
        
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: Namespace
        metadata:
          name: ${DB_NS}
        ---
        apiVersion: db.microsoft.com/preview
        kind: DocumentDB
        metadata:
          name: ${DB_NAME}
          namespace: ${DB_NS}
        spec:
          nodeCount: ${{ matrix.test_scenario.node_count }}
          instancesPerNode: ${{ matrix.test_scenario.instances_per_node }}
          documentDBImage: ghcr.io/microsoft/documentdb/documentdb-local:${{ github.event.inputs.documentdb_version || '16' }}
          resource:
            pvcSize: 10Gi
          publicLoadBalancer:
            enabled: false
        EOF

    - name: Wait for DocumentDB cluster to be ready
      run: |
        echo "Waiting for DocumentDB cluster to be ready on ${{ matrix.architecture }}..."
        
        # Calculate expected pod count
        expected_pods=${{ matrix.test_scenario.node_count }}
        
        timeout=900  # 15 minutes
        end_time=$((SECONDS + timeout))
        
        while [ $SECONDS -lt $end_time ]; do
          ready_pods=$(kubectl get pods -n $DB_NS -l cnpg.io/cluster=$DB_NAME -o json | \
                       jq '.items[] | select(.status.phase == "Running" and ([.status.containerStatuses[] | .ready] | all))' | \
                       jq -s 'length')
          
          if [[ "$ready_pods" -eq "$expected_pods" ]]; then
            echo "DocumentDB cluster is ready on ${{ matrix.architecture }}! ($ready_pods/$expected_pods pods ready)"
            break
          fi
          
          echo "Waiting for DocumentDB pods on ${{ matrix.architecture }}... ($ready_pods/$expected_pods ready)"
          kubectl get pods -n $DB_NS
          sleep 15
        done
        
        if [ $SECONDS -ge $end_time ]; then
          echo "Timeout waiting for DocumentDB cluster on ${{ matrix.architecture }}"
          kubectl describe pods -n $DB_NS
          exit 1
        fi

    - name: Comprehensive mongosh tests
      run: |
        echo "Running comprehensive mongosh tests on ${{ matrix.architecture }}..."
        
        # Start port-forward
        kubectl port-forward pod/${DB_NAME}-1 $DB_PORT:$DB_PORT -n $DB_NS &
        PF_PID=$!
        
        # Wait for port-forward
        sleep 15
        timeout 60 bash -c 'until nc -z 127.0.0.1 '$DB_PORT'; do sleep 2; done'
        
        # Create comprehensive test script with validation
        cat > comprehensive_test.js << 'EOF'
        // Comprehensive DocumentDB test suite with validation
        print("=== Starting Comprehensive DocumentDB Tests with Validation ===");
        
        // Validation helper function
        function validate(condition, message) {
          if (!condition) {
            print("DEBUG: Validation failed for: " + message);
            print("DEBUG: Condition was:", condition);
            throw new Error("VALIDATION FAILED: " + message);
          }
          print("✓ " + message);
        }
        
        // Test 1: Basic Connection and Database Operations
        print("\n--- Test 1: Basic Database Operations ---");
        db = db.getSiblingDB('testdb');
        
        // Test collection creation
        db.createCollection("users");
        db.createCollection("products");
        db.createCollection("orders");
        
        // Validate collections were created
        var collections = db.getCollectionNames();
        validate(collections.includes("users"), "Users collection created");
        validate(collections.includes("products"), "Products collection created");
        validate(collections.includes("orders"), "Orders collection created");
        
        // Insert sample data
        var users = [
          { _id: 1, name: "John Doe", email: "john@example.com", age: 30, city: "New York" },
          { _id: 2, name: "Jane Smith", email: "jane@example.com", age: 25, city: "San Francisco" },
          { _id: 3, name: "Bob Johnson", email: "bob@example.com", age: 35, city: "Chicago" },
          { _id: 4, name: "Alice Brown", email: "alice@example.com", age: 28, city: "Seattle" }
        ];
        
        var products = [
          { _id: 1, name: "Laptop", price: 999.99, category: "Electronics", stock: 50 },
          { _id: 2, name: "Phone", price: 699.99, category: "Electronics", stock: 100 },
          { _id: 3, name: "Book", price: 19.99, category: "Education", stock: 200 },
          { _id: 4, name: "Desk", price: 299.99, category: "Furniture", stock: 25 }
        ];
        
        var orders = [
          { _id: 1, userId: 1, productId: 1, quantity: 1, total: 999.99, date: new Date() },
          { _id: 2, userId: 2, productId: 2, quantity: 2, total: 1399.98, date: new Date() },
          { _id: 3, userId: 3, productId: 3, quantity: 3, total: 59.97, date: new Date() }
        ];
        
        var userResult = db.users.insertMany(users);
        var productResult = db.products.insertMany(products);
        var orderResult = db.orders.insertMany(orders);
        
        // Debug the insert results
        print("DEBUG: userResult:", JSON.stringify(userResult));
        print("DEBUG: productResult:", JSON.stringify(productResult));
        print("DEBUG: orderResult:", JSON.stringify(orderResult));
        
        // Helper function to get insertedIds count (handles both array and object formats)
        function getInsertedCount(result) {
          if (result.insertedIds) {
            if (Array.isArray(result.insertedIds)) {
              return result.insertedIds.length;
            } else if (typeof result.insertedIds === 'object') {
              return Object.keys(result.insertedIds).length;
            }
          }
          return 0;
        }
        
        // Validate insertions
        validate(userResult.acknowledged === true, "User insertion was acknowledged");
        validate(getInsertedCount(userResult) === 4, "Inserted exactly 4 users");
        validate(productResult.acknowledged === true, "Product insertion was acknowledged");
        validate(getInsertedCount(productResult) === 4, "Inserted exactly 4 products");
        validate(orderResult.acknowledged === true, "Order insertion was acknowledged");
        validate(getInsertedCount(orderResult) === 3, "Inserted exactly 3 orders");
        
        print("Inserted", getInsertedCount(userResult), "users");
        print("Inserted", getInsertedCount(productResult), "products");
        print("Inserted", getInsertedCount(orderResult), "orders");
        
        // Test 2: Query Operations
        print("\n--- Test 2: Query Operations ---");
        
        // Simple queries with validation
        var youngUsers = db.users.find({ age: { $lt: 30 } }).toArray();
        validate(youngUsers.length === 2, "Found exactly 2 users under 30 (Jane: 25, Alice: 28)");
        validate(youngUsers.some(u => u.name === "Jane Smith"), "Jane Smith found in young users");
        validate(youngUsers.some(u => u.name === "Alice Brown"), "Alice Brown found in young users");
        
        var expensiveProducts = db.products.find({ price: { $gt: 500 } }).toArray();
        validate(expensiveProducts.length === 2, "Found exactly 2 expensive products (Laptop, Phone)");
        validate(expensiveProducts.some(p => p.name === "Laptop"), "Laptop found in expensive products");
        validate(expensiveProducts.some(p => p.name === "Phone"), "Phone found in expensive products");
        
        // Complex queries with sorting
        var sortedUsers = db.users.find().sort({ age: -1 }).toArray();
        validate(sortedUsers.length === 4, "Sorted query returned all 4 users");
        validate(sortedUsers[0].name === "Bob Johnson" && sortedUsers[0].age === 35, "First user is Bob (35)");
        validate(sortedUsers[1].name === "John Doe" && sortedUsers[1].age === 30, "Second user is John (30)");
        validate(sortedUsers[2].name === "Alice Brown" && sortedUsers[2].age === 28, "Third user is Alice (28)");
        validate(sortedUsers[3].name === "Jane Smith" && sortedUsers[3].age === 25, "Fourth user is Jane (25)");
        
        print("Users sorted by age (desc):", sortedUsers.map(u => u.name + " (" + u.age + ")"));
        
        // Test 3: Aggregation Pipeline
        print("\n--- Test 3: Aggregation Operations ---");
        
        // Average age with validation
        var avgAge = db.users.aggregate([
          { $group: { _id: null, avgAge: { $avg: "$age" }, count: { $sum: 1 } } }
        ]).toArray();
        
        var expectedAvgAge = (30 + 25 + 35 + 28) / 4; // 29.5
        validate(avgAge.length === 1, "Aggregation returned exactly 1 result");
        validate(Math.abs(avgAge[0].avgAge - expectedAvgAge) < 0.01, "Average age is correct: " + expectedAvgAge);
        validate(avgAge[0].count === 4, "Count is correct: 4 users");
        
        print("Average user age:", avgAge[0].avgAge, "from", avgAge[0].count, "users");
        
        // Group by city with validation
        var cityGroups = db.users.aggregate([
          { $group: { _id: "$city", count: { $sum: 1 }, avgAge: { $avg: "$age" } } },
          { $sort: { count: -1 } }
        ]).toArray();
        
        validate(cityGroups.length === 4, "Grouped by 4 different cities");
        var cities = cityGroups.map(g => g._id);
        validate(cities.includes("New York"), "New York city group found");
        validate(cities.includes("San Francisco"), "San Francisco city group found");
        validate(cities.includes("Chicago"), "Chicago city group found");
        validate(cities.includes("Seattle"), "Seattle city group found");
        
        print("Users by city:", cityGroups);
        
        // Product statistics with validation
        var productStats = db.products.aggregate([
          { $group: { 
              _id: "$category", 
              count: { $sum: 1 },
              avgPrice: { $avg: "$price" },
              totalStock: { $sum: "$stock" }
          }},
          { $sort: { avgPrice: -1 } }
        ]).toArray();
        
        validate(productStats.length === 3, "Grouped by 3 categories");
        var electronicsStats = productStats.find(s => s._id === "Electronics");
        validate(electronicsStats && electronicsStats.count === 2, "Electronics category has 2 products");
        validate(electronicsStats && electronicsStats.totalStock === 150, "Electronics total stock is 150");
        
        print("Product statistics by category:", productStats);
        
        // Test 4: Update Operations
        print("\n--- Test 4: Update Operations ---");
        
        // Update single document with validation
        var updateResult = db.users.updateOne(
          { name: "John Doe" },
          { $set: { age: 31, lastUpdated: new Date() } }
        );
        
        validate(updateResult.matchedCount === 1, "Update matched exactly 1 document");
        validate(updateResult.modifiedCount === 1, "Update modified exactly 1 document");
        
        // Verify the update
        var updatedJohn = db.users.findOne({ name: "John Doe" });
        validate(updatedJohn.age === 31, "John's age updated to 31");
        validate(updatedJohn.lastUpdated !== undefined, "John has lastUpdated field");
        
        print("Updated", updateResult.modifiedCount, "user document");
        
        // Update multiple documents with validation
        var electronicsBeforeUpdate = db.products.find({ category: "Electronics" }).toArray();
        print("DEBUG: Electronics products before bulk update:", JSON.stringify(electronicsBeforeUpdate));
        
        var bulkUpdate = db.products.updateMany(
          { category: "Electronics" },
          { $inc: { stock: -5 }, $set: { lastSold: new Date() } }
        );
        
        print("DEBUG: bulkUpdate result:", JSON.stringify(bulkUpdate));
        validate(bulkUpdate.matchedCount === 2, "Bulk update matched 2 Electronics products");
        validate(bulkUpdate.modifiedCount === 2, "Bulk update modified 2 products");
        
        // Verify bulk update
        var updatedElectronics = db.products.find({ category: "Electronics" }).toArray();
        validate(updatedElectronics.every(p => p.lastSold !== undefined), "All electronics have lastSold field");
        var laptop = updatedElectronics.find(p => p.name === "Laptop");
        var phone = updatedElectronics.find(p => p.name === "Phone");
        validate(laptop.stock === 45, "Laptop stock reduced to 45");
        validate(phone.stock === 95, "Phone stock reduced to 95");
        
        print("Updated", bulkUpdate.modifiedCount, "product documents");
        
        // Upsert operation with validation
        var existingUser = db.users.findOne({ email: "new@example.com" });
        print("DEBUG: Existing user with new@example.com:", JSON.stringify(existingUser));
        
        var upsertResult = db.users.updateOne(
          { email: "new@example.com" },
          { $set: { name: "New User", age: 22, city: "Boston" } },
          { upsert: true }
        );
        
        print("DEBUG: upsertResult:", JSON.stringify(upsertResult));
        validate(upsertResult.matchedCount === 0, "Upsert matched 0 existing documents");
        validate(upsertResult.modifiedCount === 0, "Upsert modified 0 existing documents");
        validate(upsertResult.upsertedCount === 1, "Upsert created 1 new document");
        
        // Verify upsert
        var newUser = db.users.findOne({ email: "new@example.com" });
        validate(newUser && newUser.name === "New User", "New user created with correct name");
        validate(newUser && newUser.age === 22, "New user has correct age");
        
        print("Upsert operation - matched:", upsertResult.matchedCount, "modified:", upsertResult.modifiedCount, "upserted:", upsertResult.upsertedCount);
        
        // Test 5: Text Search
        print("\n--- Test 5: Text Search ---");
        
        // Simple text search without text index
        var laptopProducts = db.products.find({ name: /laptop/i }).toArray();
        validate(laptopProducts.length === 1, "Text search found exactly 1 laptop");
        validate(laptopProducts[0].name === "Laptop", "Found product is the Laptop");
        
        print("Text search for 'laptop' found:", laptopProducts.length, "products");
        
        // Test 6: Array Operations
        print("\n--- Test 6: Array Operations ---");
        
        // Count users before adding hobbies array
        var userCountBefore = db.users.countDocuments();
        print("DEBUG: User count before adding hobbies:", userCountBefore);
        
        // Add array field to users
        var arrayUpdateResult = db.users.updateMany(
          {},
          { $set: { hobbies: [] } }
        );
        print("DEBUG: arrayUpdateResult:", JSON.stringify(arrayUpdateResult));
        validate(arrayUpdateResult.modifiedCount === userCountBefore, "Added hobbies array to all " + userCountBefore + " users");
        
        // Update with array operations
        var johnHobbiesResult = db.users.updateOne(
          { name: "John Doe" },
          { $push: { hobbies: { $each: ["reading", "gaming", "cooking"] } } }
        );
        validate(johnHobbiesResult.modifiedCount === 1, "Added hobbies to John");
        
        var janeHobbiesResult = db.users.updateOne(
          { name: "Jane Smith" },
          { $push: { hobbies: { $each: ["traveling", "photography"] } } }
        );
        validate(janeHobbiesResult.modifiedCount === 1, "Added hobbies to Jane");
        
        var usersWithHobbies = db.users.find({ hobbies: { $exists: true, $ne: [] } }).toArray();
        validate(usersWithHobbies.length === 2, "Found exactly 2 users with hobbies");
        
        // Array query operations
        var readingUsers = db.users.find({ hobbies: "reading" }).toArray();
        validate(readingUsers.length === 1, "Found exactly 1 user who likes reading");
        validate(readingUsers[0].name === "John Doe", "John Doe likes reading");
        
        print("Users with hobbies:", usersWithHobbies.length);
        print("Users who like reading:", readingUsers.length);
        
        // Test 7: Date Operations
        print("\n--- Test 7: Date Operations ---");
        
        var today = new Date();
        var yesterday = new Date(today.getTime() - 24 * 60 * 60 * 1000);
        
        var recentOrders = db.orders.find({ date: { $gte: yesterday } }).toArray();
        validate(recentOrders.length === 3, "All 3 orders are recent (created today)");
        
        // Date aggregation
        var dailyStats = db.orders.aggregate([
          { $group: {
              _id: { $dateToString: { format: "%Y-%m-%d", date: "$date" } },
              totalOrders: { $sum: 1 },
              totalAmount: { $sum: "$total" }
          }}
        ]).toArray();
        
        validate(dailyStats.length === 1, "Orders grouped into 1 day");
        validate(dailyStats[0].totalOrders === 3, "Total orders for today is 3");
        var expectedTotal = 999.99 + 1399.98 + 59.97;
        validate(Math.abs(dailyStats[0].totalAmount - expectedTotal) < 0.01, "Total amount is correct");
        
        print("Recent orders:", recentOrders.length);
        print("Daily order statistics:", dailyStats);
        
        // Test 8: Batch Operations
        print("\n--- Test 8: Batch Operations ---");
        
        var bulkOps = db.products.initializeUnorderedBulkOp();
        bulkOps.find({ category: "Electronics" }).update({ $inc: { views: 1 } });
        bulkOps.find({ price: { $lt: 100 } }).update({ $set: { featured: true } });
        bulkOps.insert({ name: "New Product", price: 49.99, category: "Test", stock: 10 });
        
        var bulkResult = bulkOps.execute();
        
        validate(bulkResult.nMatched >= 3, "Bulk operations matched at least 3 documents"); // 2 electronics + 1 book
        validate(bulkResult.nModified >= 3, "Bulk operations modified at least 3 documents");
        validate(bulkResult.nInserted === 1, "Bulk operations inserted 1 document");
        
        // Verify bulk operations
        var electronicsWithViews = db.products.find({ category: "Electronics", views: { $exists: true } }).toArray();
        validate(electronicsWithViews.length === 2, "Both electronics products have views field");
        
        var featuredProducts = db.products.find({ featured: true }).toArray();
        validate(featuredProducts.length >= 1, "At least 1 product is featured"); // Book should be featured
        
        var newProduct = db.products.findOne({ name: "New Product" });
        validate(newProduct !== null, "New product was inserted");
        validate(newProduct.price === 49.99, "New product has correct price");
        
        print("Bulk operation results - matched:", bulkResult.nMatched, "modified:", bulkResult.nModified, "inserted:", bulkResult.nInserted);
        
        // Test 9: Final Verification
        print("\n--- Test 9: Final Data Verification ---");
        
        var totalUsers = db.users.countDocuments();
        var totalProducts = db.products.countDocuments();
        var totalOrders = db.orders.countDocuments();
        
        print("DEBUG: Final counts - Users:", totalUsers, "Products:", totalProducts, "Orders:", totalOrders);
        
        // Use dynamic validation based on actual counts (4 original + 1 upserted = 5)
        var expectedUsers = 5; // 4 original + 1 upserted
        var expectedProducts = 5; // 4 original + 1 bulk inserted  
        var expectedOrders = 3; // 3 original
        
        validate(totalUsers === expectedUsers, "Final user count is " + expectedUsers + " (4 original + 1 upserted)");
        validate(totalProducts === expectedProducts, "Final product count is " + expectedProducts + " (4 original + 1 bulk inserted)");
        validate(totalOrders === expectedOrders, "Final order count is " + expectedOrders);
        
        print("Final counts - Users:", totalUsers, "Products:", totalProducts, "Orders:", totalOrders);
        
        // Test data consistency
        var allUsersHaveHobbies = db.users.find({ hobbies: { $exists: false } }).toArray();
        validate(allUsersHaveHobbies.length === 0, "All users have hobbies field");
        
        var johnFinal = db.users.findOne({ name: "John Doe" });
        print("DEBUG: John final state:", JSON.stringify(johnFinal));
        validate(johnFinal !== null, "John Doe document exists at end");
        validate(johnFinal.age === 31, "John's age is still 31");
        validate(johnFinal.hobbies && johnFinal.hobbies.includes("reading"), "John still has reading hobby");
        
        // Clean up test data
        print("\n--- Cleanup ---");
        db.users.drop();
        db.products.drop();
        db.orders.drop();
        
        // Verify cleanup
        var remainingCollections = db.getCollectionNames();
        validate(!remainingCollections.includes("users"), "Users collection dropped");
        validate(!remainingCollections.includes("products"), "Products collection dropped");
        validate(!remainingCollections.includes("orders"), "Orders collection dropped");
        
        print("\n=== All Tests Completed Successfully with Validation on ${{ matrix.architecture }}! ===");
        EOF
        
        # Run comprehensive tests with validation
        echo "Running comprehensive mongosh validation tests..."
        if mongosh 127.0.0.1:$DB_PORT \
          -u $DB_USERNAME \
          -p $DB_PASSWORD \
          --authenticationMechanism SCRAM-SHA-256 \
          --tls \
          --tlsAllowInvalidCertificates \
          --file comprehensive_test.js; then
          echo "✓ Comprehensive mongosh tests completed successfully on ${{ matrix.architecture }}"
        else
          echo "❌ Comprehensive mongosh tests failed on ${{ matrix.architecture }}"
          exit 1
        fi
        
        # Stop port-forward
        kill $PF_PID

    - name: Performance and Load Testing
      run: |
        echo "Running performance tests on ${{ matrix.architecture }}..."
        
        # Start port-forward
        kubectl port-forward pod/${DB_NAME}-1 $DB_PORT:$DB_PORT -n $DB_NS &
        PF_PID=$!
        sleep 10
        
        # Create performance test script with validation
        cat > performance_test.js << 'EOF'
        print("=== Performance Test Suite with Validation ===");
        
        // Validation helper function
        function validate(condition, message) {
          if (!condition) {
            print("DEBUG: Performance validation failed for: " + message);
            print("DEBUG: Condition was:", condition);
            throw new Error("PERFORMANCE VALIDATION FAILED: " + message);
          }
          print("✓ " + message);
        }
        
        db = db.getSiblingDB('perftest');
        
        // Large dataset insertion test
        print("\n--- Large Dataset Insertion Test ---");
        var startTime = new Date();
        var docs = [];
        for (let i = 0; i < 1000; i++) {
          docs.push({
            id: i,
            name: "User " + i,
            email: "user" + i + "@example.com",
            data: "This is sample data for user " + i,
            timestamp: new Date(),
            metadata: {
              source: "performance_test",
              batch: Math.floor(i / 100),
              random: Math.random()
            }
          });
        }
        
        validate(docs.length === 1000, "Created exactly 1000 test documents");
        
        var insertStart = new Date();
        var result = db.perfcollection.insertMany(docs);
        var insertEnd = new Date();
        
        // Debug the insert result
        print("DEBUG: performance insertMany result:", JSON.stringify(result));
        
        // Helper function to get insertedIds count (handles both array and object formats)
        function getInsertedCount(result) {
          if (result.insertedIds) {
            if (Array.isArray(result.insertedIds)) {
              return result.insertedIds.length;
            } else if (typeof result.insertedIds === 'object') {
              return Object.keys(result.insertedIds).length;
            }
          }
          return 0;
        }
        
        var insertTime = insertEnd - insertStart;
        validate(result.acknowledged === true, "Insertion was acknowledged");
        validate(getInsertedCount(result) === 1000, "Inserted exactly 1000 documents");
        validate(insertTime < 10000, "Insertion completed within 10 seconds (took " + insertTime + "ms)");
        
        print("Inserted", getInsertedCount(result), "documents in", insertTime, "ms");
        
        // Query performance test
        print("\n--- Query Performance Test ---");
        
        var queryStart = new Date();
        var count = db.perfcollection.countDocuments();
        var queryEnd = new Date();
        
        var countTime = queryEnd - queryStart;
        validate(count === 1000, "Count query returned correct result: 1000");
        validate(countTime < 5000, "Count query completed within 5 seconds (took " + countTime + "ms)");
        
        print("Count query took", countTime, "ms, result:", count);
        
        // Range query performance test
        print("\n--- Range Query Performance Test ---");
        
        var queryStart2 = new Date();
        var rangeResults = db.perfcollection.find({ id: { $gte: 500 } }).toArray();
        var queryEnd2 = new Date();
        
        var rangeTime = queryEnd2 - queryStart2;
        validate(rangeResults.length === 500, "Range query returned exactly 500 documents");
        validate(rangeTime < 5000, "Range query completed within 5 seconds (took " + rangeTime + "ms)");
        
        // Validate range query results
        var minId = Math.min(...rangeResults.map(r => r.id));
        var maxId = Math.max(...rangeResults.map(r => r.id));
        validate(minId === 500, "Minimum ID in range results is 500");
        validate(maxId === 999, "Maximum ID in range results is 999");
        
        print("Range query found", rangeResults.length, "documents in", rangeTime, "ms");
        
        // Aggregation performance
        print("\n--- Aggregation Performance Test ---");
        
        var aggStart = new Date();
        var aggResult = db.perfcollection.aggregate([
          { $match: { id: { $gte: 100 } } },
          { $group: { _id: "$metadata.batch", count: { $sum: 1 }, avgId: { $avg: "$id" } } },
          { $sort: { _id: 1 } }
        ]).toArray();
        var aggEnd = new Date();
        
        var aggTime = aggEnd - aggStart;
        validate(aggResult.length === 9, "Aggregation returned 9 batches (batches 1-9)"); // 100-999 = batches 1-9
        validate(aggTime < 5000, "Aggregation completed within 5 seconds (took " + aggTime + "ms)");
        
        // Validate aggregation results
        var totalDocs = aggResult.reduce((sum, batch) => sum + batch.count, 0);
        validate(totalDocs === 900, "Aggregation processed exactly 900 documents (id >= 100)");
        
        // Check specific batch
        var batch5 = aggResult.find(r => r._id === 5);
        validate(batch5 && batch5.count === 100, "Batch 5 has exactly 100 documents");
        validate(batch5 && Math.abs(batch5.avgId - 549.5) < 0.1, "Batch 5 average ID is correct (~549.5)");
        
        print("Aggregation processed", aggResult.length, "groups in", aggTime, "ms");
        
        // Test sorting performance
        print("\n--- Sorting Performance Test ---");
        
        var sortStart = new Date();
        var sortedResults = db.perfcollection.find({ id: { $lt: 100 } }).sort({ id: -1 }).toArray();
        var sortEnd = new Date();
        
        var sortTime = sortEnd - sortStart;
        validate(sortedResults.length === 100, "Sort query returned exactly 100 documents");
        validate(sortTime < 3000, "Sort query completed within 3 seconds (took " + sortTime + "ms)");
        
        // Validate sorting
        validate(sortedResults[0].id === 99, "First document has ID 99 (descending sort)");
        validate(sortedResults[99].id === 0, "Last document has ID 0 (descending sort)");
        
        for (let i = 0; i < sortedResults.length - 1; i++) {
          validate(sortedResults[i].id > sortedResults[i + 1].id, "Documents are sorted in descending order");
        }
        
        print("Sort query processed", sortedResults.length, "documents in", sortTime, "ms");
        
        // Test update performance
        print("\n--- Update Performance Test ---");
        
        var updateStart = new Date();
        var updateResult = db.perfcollection.updateMany(
          { "metadata.batch": { $in: [0, 1, 2] } },
          { $set: { updated: true, updateTime: new Date() } }
        );
        var updateEnd = new Date();
        
        var updateTime = updateEnd - updateStart;
        validate(updateResult.matchedCount === 300, "Update matched exactly 300 documents (3 batches × 100)");
        validate(updateResult.modifiedCount === 300, "Update modified exactly 300 documents");
        validate(updateTime < 3000, "Update completed within 3 seconds (took " + updateTime + "ms)");
        
        // Verify updates
        var updatedDocs = db.perfcollection.find({ updated: true }).toArray();
        validate(updatedDocs.length === 300, "Found exactly 300 updated documents");
        validate(updatedDocs.every(doc => doc.updateTime !== undefined), "All updated docs have updateTime");
        
        print("Update modified", updateResult.modifiedCount, "documents in", updateTime, "ms");
        
        // Test delete performance
        print("\n--- Delete Performance Test ---");
        
        var deleteStart = new Date();
        var deleteResult = db.perfcollection.deleteMany({ id: { $gte: 950 } });
        var deleteEnd = new Date();
        
        var deleteTime = deleteEnd - deleteStart;
        validate(deleteResult.deletedCount === 50, "Deleted exactly 50 documents (IDs 950-999)");
        validate(deleteTime < 2000, "Delete completed within 2 seconds (took " + deleteTime + "ms)");
        
        // Verify deletions
        var remainingCount = db.perfcollection.countDocuments();
        validate(remainingCount === 950, "Exactly 950 documents remain after deletion");
        
        var deletedDocs = db.perfcollection.find({ id: { $gte: 950 } }).toArray();
        validate(deletedDocs.length === 0, "No documents with ID >= 950 remain");
        
        print("Delete removed", deleteResult.deletedCount, "documents in", deleteTime, "ms");
        
        // Overall performance summary
        print("\n--- Performance Summary ---");
        var totalTime = new Date() - startTime;
        validate(totalTime < 30000, "All performance tests completed within 30 seconds (took " + totalTime + "ms)");
        
        print("Total performance test time:", totalTime, "ms");
        print("Insert rate:", Math.round(1000 / (insertTime / 1000)), "docs/sec");
        print("Query rate:", Math.round(1000 / (countTime / 1000)), "queries/sec");
        print("Update rate:", Math.round(300 / (updateTime / 1000)), "updates/sec");
        print("Delete rate:", Math.round(50 / (deleteTime / 1000)), "deletes/sec");
        
        // Cleanup with validation
        var dropStart = new Date();
        db.perfcollection.drop();
        var dropEnd = new Date();
        
        var dropTime = dropEnd - dropStart;
        validate(dropTime < 2000, "Collection drop completed within 2 seconds (took " + dropTime + "ms)");
        
        // Verify cleanup
        var collections = db.getCollectionNames();
        validate(!collections.includes("perfcollection"), "Performance collection was dropped");
        
        print("\n=== Performance Tests Completed Successfully with Validation on ${{ matrix.architecture }}! ===");
        EOF
        
        echo "Running performance validation tests..."
        if mongosh 127.0.0.1:$DB_PORT \
          -u $DB_USERNAME \
          -p $DB_PASSWORD \
          --authenticationMechanism SCRAM-SHA-256 \
          --tls \
          --tlsAllowInvalidCertificates \
          --file performance_test.js; then
          echo "✓ Performance tests completed successfully on ${{ matrix.architecture }}"
        else
          echo "❌ Performance tests failed on ${{ matrix.architecture }}"
          exit 1
        fi
        
        kill $PF_PID

    - name: Test cluster health and monitoring
      run: |
        echo "Testing cluster health and monitoring on ${{ matrix.architecture }}..."
        
        # Check DocumentDB resource status
        kubectl get documentdb $DB_NAME -n $DB_NS -o yaml
        
        # Check pod resources and health
        kubectl top pods -n $DB_NS --containers || echo "Metrics server not available"
        
        # Check logs for any errors
        kubectl logs -n $DB_NS -l cnpg.io/cluster=$DB_NAME --tail=50
        
        # Check events
        kubectl get events -n $DB_NS --sort-by='.lastTimestamp'

    - name: Collect comprehensive logs on failure
      if: failure()
      run: |
        echo "=== Comprehensive Failure Diagnostics for ${{ matrix.architecture }} ==="
        
        # Check if kubectl is working
        if ! kubectl version --client &>/dev/null; then
          echo "kubectl not available"
          exit 0
        fi
        
        # Check if cluster is accessible
        if ! kubectl cluster-info &>/dev/null; then
          echo "Cluster not accessible"
          kubectl config current-context || echo "No kubectl context found"
          kubectl config get-contexts || echo "No contexts available"
          exit 0
        fi
        
        echo "=== System Information ==="
        kubectl version --client || echo "Failed to get kubectl version"
        helm version || echo "Failed to get helm version"
        docker --version || echo "Failed to get docker version"
        
        echo "=== Cluster State ==="
        kubectl get nodes -o wide || echo "Failed to get nodes"
        kubectl get pods --all-namespaces -o wide || echo "Failed to get pods"
        
        echo "=== DocumentDB Resources ==="
        kubectl get documentdb -A -o yaml || echo "Failed to get DocumentDB resources"
        kubectl describe documentdb $DB_NAME -n $DB_NS || echo "Failed to describe DocumentDB"
        
        echo "=== Storage Information ==="
        kubectl get pv,pvc -A || echo "Failed to get storage info"
        
        echo "=== Pod Details ==="
        kubectl describe pods -n $DB_NS || echo "Failed to describe pods"
        
        echo "=== Container Logs ==="
        for pod in $(kubectl get pods -n $DB_NS -o name 2>/dev/null); do
          echo "--- Logs for $pod ---"
          kubectl logs $pod -n $DB_NS --all-containers=true --tail=100 || echo "Failed to get logs for $pod"
        done
        
        echo "=== Operator Logs ==="
        kubectl logs -n $OPERATOR_NS deployment/documentdb-operator --tail=200 || echo "Failed to get operator logs"
        
        echo "=== CNPG Operator Logs ==="
        kubectl logs -n cnpg-system --all-containers=true --tail=100 || echo "CNPG logs not available"
        
        echo "=== Events ==="
        kubectl get events --all-namespaces --sort-by='.lastTimestamp' || echo "Failed to get events"

